% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_2gp.R
\name{compute_2gp}
\alias{compute_2gp}
\title{computes a vector of second generation p values}
\usage{
compute_2gp(null_scale = 0.15, lambdas, ci_lowers, ci_uppers)
}
\arguments{
\item{null_scale}{a scalar to adjust the size of your null interval, defaults to 0.15}

\item{lambdas}{a vector of lambda values, where lambda is an upper bound on available resources, expressed in terms of currency}

\item{ci_lowers}{a vector of the same length as \code{lambdas}, holding the lower CI bound of the net monetary benefits, often coming from the output of \code{ci_nmb()}}

\item{ci_uppers}{a vector of the same length as \code{lambdas}, holding the upper CI bound of the net monetary benefits, often coming from the output of \code{ci_nmb()}}
}
\value{
vector of 2nd generation p-values for each lambda value
}
\description{
uses the formula from Blume et. al (2018) to compute a second-generation p-value for each treatment comparison at each lambda
}
\examples{
B <- 1000
conf_level <- 0.95
A <- rbinom(N, 1, 0.5)
Z <- rnorm(N, 50 + 4.5 * A, 4)
Y <- rnorm(N, 100 + 2 * A, 5)
lambdas <- c(0:1000)/500
df <- prep_data(A,Z,Y)
conf_ints <- ci_nmb(df, lambdas, B, conf_level)
null_scale <- 0.15
compute_2gp(null_scale, lambdas, conf_ints$lower_bounds, conf_ints$upper_bounds)

}
